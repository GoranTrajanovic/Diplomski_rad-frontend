import { useEffect, useState } from "react";
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { useRouter } from "next/router";
import ListOfURLs from "../components/ListOfURLs/ListOfURLs";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import SuccessIcon from "@/components/AnimatedIcons/SuccessIcon/SuccessIcon";
import ErrorIcon from "@/components/AnimatedIcons/ErrorIcon/ErrorIcon";
import CircularProgress from "@mui/material/CircularProgress";
import ReplayIcon from "@mui/icons-material/Replay";
import IconButton from "@mui/material/IconButton";
import Autocomplete from "@mui/material/Autocomplete";

import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import Modal from "@mui/material/Modal";
import { fetcher } from "../misc/fetcher";
import { websiteDataProps } from "./../misc/types";
import getRootURL from "./../misc/getRootURL";

type DataURLs = {
	fullURLs: string[];
	errorMsg?: string;
};

type DataAuthors = {
	authorsArray: string[];
	errorMsg?: string;
};

export default function Home({
	webSitesFetched,
}: {
	webSitesFetched: websiteDataProps[];
}) {
	const [currentInputValue, setCurrentInputValue] = useState("");
	const [rootURLsubmissionStatus, setRootURLsubmissionStatus] =
		useState("unsubmitted");
	const [fullURLs, setFullURLs] = useState<string[]>([]);
	const [modalOpen, setModalOpen] = useState(false);
	const [allAuthors, setAllAuthors] = useState<string[]>([]);
	const [selectedAuthors, setSelectedAuthors] = useState<string[]>([]);
	const [storedAuthors, setStoredAuthors] = useState<string[]>([]);

	const router = useRouter();

	useEffect(() => {
		const keyDownHandler = (e: KeyboardEvent) => {
			if (e.code === "Enter") handleSubmitButton();
		};
		document.addEventListener("keydown", keyDownHandler);

		return () => {
			document.removeEventListener("keydown", keyDownHandler);
		};
	}, []);

	function handleInputChange(e: React.ChangeEvent<HTMLInputElement>) {
		setCurrentInputValue(e.currentTarget.value);
		setRootURLsubmissionStatus("unsubmitted");
	}

	async function handleSubmitButton() {
		let rootURLforProcessing: string = "";
		if (isURLvalid(currentInputValue)) {
			rootURLforProcessing = makeURLcompatible(currentInputValue);
			router.push(`/?link=${rootURLforProcessing}`);
			setRootURLsubmissionStatus("loading");

			webSitesFetched.map(website => {
				if (website.attributes.Root_URL === getRootURL(currentInputValue))
					setStoredAuthors(
						website.attributes.website_authors.data.map(
							author =>
								`${author.attributes.Name} ${author.attributes.Surname} (${author.id})`
						)
					);
			});

			const resURLs = await fetch("/api/fetch_all_webpage_urls", {
				method: "POST",
				body: JSON.stringify({ rootURL: rootURLforProcessing }),
				headers: { "content-type": "application/json" },
			});

			if (!resURLs.ok) {
				// const error = await resURLs.text();
				setRootURLsubmissionStatus("error");
			} else {
				const data: DataURLs = await resURLs.json();
				setRootURLsubmissionStatus("complete");
				setFullURLs([...data.fullURLs]);
			}

			const resAuthors = await fetch("/api/fetch_all_authors_in_db", {
				method: "GET",
				headers: { "content-type": "application/json" },
			});

			if (!resAuthors.ok) {
				const error = await resAuthors.text();
			} else {
				const data: DataAuthors = await resAuthors.json();
				setAllAuthors(data.authorsArray);
			}
		} else setRootURLsubmissionStatus("error");
	}

	const handleModalOpen = () => setModalOpen(true);
	const handleModalClose = () => setModalOpen(false);

	return (
		<>
			<Head>
				<title>Create Next App</title>
				<meta name="description" content="Generated by create next app" />
				<meta name="viewport" content="width=device-width, initial-scale=1" />
				<link rel="icon" href="/favicon.ico" />
			</Head>
			<main className={styles.main}>
				<div className={styles.link_form}>
					<TextField
						variant="outlined"
						label="Insert your link here..."
						className={styles.text_field}
						autoComplete="on"
						name="URL"
						value={currentInputValue}
						onChange={handleInputChange}
					></TextField>
					<Button
						variant="outlined"
						type="submit"
						onClick={handleSubmitButton}
						className={styles[`submit-button-${rootURLsubmissionStatus}`]}
					>
						{rootURLsubmissionStatus === "loading" ? (
							<CircularProgress
								className={styles.loading_spinner}
								size="1.8rem"
							/>
						) : rootURLsubmissionStatus === "complete" ? (
							<SuccessIcon />
						) : rootURLsubmissionStatus === "error" ? (
							<ErrorIcon />
						) : (
							"Submit"
						)}
					</Button>

					<IconButton
						aria-label="delete"
						className={
							styles[
								rootURLsubmissionStatus === "error" ? "repeat-button" : "hidden"
							]
						}
						onClick={handleSubmitButton}
					>
						<ReplayIcon />
					</IconButton>
				</div>
				<div className={styles.processing_status}>
					<span>
						{rootURLsubmissionStatus === "loading"
							? "Processing: "
							: rootURLsubmissionStatus === "complete"
							? "Processed: "
							: rootURLsubmissionStatus === "error"
							? "Error in processing: "
							: null}
					</span>
					<span className={styles.bold}>
						{rootURLsubmissionStatus === "unsubmitted"
							? null
							: currentInputValue}
					</span>
				</div>

				{rootURLsubmissionStatus !== "complete" ? null : (
					<Autocomplete
						multiple
						onChange={(event, value) => setSelectedAuthors(value)}
						id="tags-outlined"
						options={allAuthors.map(author => author)}
						getOptionLabel={author => author}
						filterSelectedOptions
						defaultValue={storedAuthors}
						renderInput={params => (
							<TextField
								{...params}
								label="Select Website Author(s)..."
								placeholder=""
							/>
						)}
					/>
				)}

				{rootURLsubmissionStatus !== "complete" ? null : (
					<ListOfURLs
						fullURLs={fullURLs}
						authors={selectedAuthors}
						handleModalOpen={handleModalOpen}
					/>
				)}

				<Modal
					open={modalOpen}
					onClose={handleModalClose}
					aria-labelledby="modal-modal-title"
					aria-describedby="modal-modal-description"
				>
					<Box className={styles.modal_box}>
						<Typography
							id="modal-modal-title"
							variant="h6"
							component="h2"
							className={styles.modal_title}
						>
							No Root Selected
						</Typography>
						<Typography id="modal-modal-description" sx={{ mt: 2 }}>
							Please select root URL for <b>{currentInputValue}</b> as there is
							not one in database already. <br />
							<br />
							<u>All webpages are connected to the root webpage.</u>
						</Typography>
						<Button variant="text" onClick={handleModalClose}>
							Ok
						</Button>
					</Box>
				</Modal>
			</main>
		</>
	);
}

export async function getStaticProps() {
	// let webSitesResponse: webSitesResponseProps;
	let webSitesResponse;

	try {
		webSitesResponse = await fetcher(
			`${process.env.NEXT_PUBLIC_STRAPI_URL}/websites?populate=*`
		);
	} catch (err) {
		console.log(err);
	}

	return {
		props: {
			webSitesFetched: webSitesResponse.data,
		},
	};
}

function isURLvalid(url: string): boolean {
	// const regex = new RegExp("^(https?://){0,1}[a-z0-9]+.[a-z]+$");
	const regex = new RegExp("^(https?://){0,1}[a-z0-9]+(.[a-z]+)+/{0,1}$");
	return regex.test(url);
}

function makeURLcompatible(url: string): string {
	if (!url.includes("http")) url = "http://" + url;
	if (url.lastIndexOf("/") + 1 !== url.length) url = url + "/";
	// if (url.lastIndexOf("/") + 1 === url.length) tempURL = url.slice(0, -1);
	return url;
}
