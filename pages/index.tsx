import { useState, useEffect } from "react";
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { chromium, devices } from "playwright";
import { useRouter } from "next/router";
import { makeURLsFromHrefs } from "@/helper_functions/makeURLsFromHrefs";
import ListOfURLs from "../components/ListOfURLs/ListOfURLs";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import SuccessIcon from "@/components/AnimatedIcons/SuccessIcon/SuccessIcon";
import ErrorIcon from "@/components/AnimatedIcons/ErrorIcon/ErrorIcon";
import CircularProgress from "@mui/material/CircularProgress";
import ReplayIcon from "@mui/icons-material/Replay";
import IconButton from "@mui/material/IconButton";

type Data = {
	fullURLs: string[];
	errorMsg?: string;
};

export default function Home() {
	const [currentInputValue, setCurrentInputValue] = useState("");
	const [rootURLsubmissionStatus, setRootURLsubmissionStatus] =
		useState("unsubmitted");
	const router = useRouter();

	function handleInputChange(e: React.ChangeEvent<HTMLInputElement>) {
		setCurrentInputValue(e.currentTarget.value);
		setRootURLsubmissionStatus("unsubmitted");
		console.log(currentInputValue);
	}

	async function handleSubmitButton(e: React.MouseEvent<HTMLButtonElement>) {
		router.push(`/?link=${currentInputValue}`);
		setRootURLsubmissionStatus("loading");

		const res = await fetch("/api/fetch_all_webpage_urls", {
			method: "POST",
			body: JSON.stringify({ rootURL: currentInputValue }),
			headers: { "content-type": "application/json" },
		});

		if (!res.ok) {
			const error = await res.text();
			// throw new Error(error);
			setRootURLsubmissionStatus("error");
		} else {
			const data: Data = await res.json();
			setRootURLsubmissionStatus("complete");

			console.log(data);
		}
	}

	// console.log(fullURLs);

	return (
		<>
			<Head>
				<title>Create Next App</title>
				<meta name="description" content="Generated by create next app" />
				<meta name="viewport" content="width=device-width, initial-scale=1" />
				<link rel="icon" href="/favicon.ico" />
			</Head>
			<main className={styles.main}>
				<div className={styles.link_form}>
					<TextField
						variant="outlined"
						label="Insert your link here..."
						className={styles.text_field}
						autoComplete="on"
						name="URL"
						value={currentInputValue}
						onChange={handleInputChange}
					></TextField>
					<Button
						variant="outlined"
						type="submit"
						onClick={handleSubmitButton}
						className={styles[`submit-button-${rootURLsubmissionStatus}`]}
					>
						{rootURLsubmissionStatus === "loading" ? (
							<CircularProgress
								className={styles.loading_spinner}
								size="1.8rem"
							/>
						) : rootURLsubmissionStatus === "complete" ? (
							<SuccessIcon />
						) : rootURLsubmissionStatus === "error" ? (
							<ErrorIcon />
						) : (
							"Submit"
						)}
					</Button>

					<IconButton
						aria-label="delete"
						className={
							styles[
								rootURLsubmissionStatus === "error" ? "repeat-button" : "hidden"
							]
						}
						onClick={handleSubmitButton}
					>
						<ReplayIcon />
					</IconButton>
				</div>
				<h2>
					{rootURLsubmissionStatus === "loading"
						? "Processing: "
						: rootURLsubmissionStatus === "complete"
						? "Processed: "
						: rootURLsubmissionStatus === "error"
						? "Error in processing: "
						: null}
					{rootURLsubmissionStatus === "unsubmitted" ? null : currentInputValue}
				</h2>

				{/* <ListOfURLs fullURLs={fullURLs} /> */}

				{/* {buttonClicked && <FetchedLinks />} */}
				{/* <BrowseAllButton /> */}
			</main>
		</>
	);
}

/* export async function getServerSideProps(context: { query: { link: string } }) {
	const link = context.query.link || "";
	const hrefs = [];
	let fullURLs: (string | undefined)[] = [];

	// console.log("This is link from getServerSideProps");
	// console.log(link);

	const browser = await chromium.launch();
	const contextPW = await browser.newContext();
	// const context = await browser.newContext(devices["iPhone 11"]);
	const page = await contextPW.newPage();

	try {
		await page.goto(link);
		const links = await page.locator("a");
		const linksCount = await links.count();
		const texts = await page.getByRole("link").allTextContents();

		for (let i = 0; i < linksCount; i++) {
			hrefs.push(await links.nth(i).getAttribute("href"));
		}

		// console.log("Links from index.tsx:");
		fullURLs = makeURLsFromHrefs(link, hrefs);

		fullURLs = [
			...fullURLs.map(fullURL => {
				if (fullURL !== undefined) {
					if (fullURL.lastIndexOf("/") + 1 === fullURL.length)
						return fullURL.slice(0, fullURL.lastIndexOf("/"));
					else return fullURL;
				}
			}),
		];
		// takeScreenshotsForAllURLs(fullURLs);
	} catch (err) {
		console.log(err);
	}

	// Teardown
	await contextPW.close();
	await browser.close();

	return { props: { fullURLs } };
}
 */
